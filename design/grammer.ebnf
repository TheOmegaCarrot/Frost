(* 
 https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form
 vim:ft=ebnf
 *)

mustblank = { ' ' | '\t' | '\n' } ;

blank = [ mustblank ] ;

sep = { '\n' | ';' } ;

toplevel = { decl } ;

decl = id, blank, '=', blank, ( expr | fn_defn ), sep ;

(* id = C identifier rules *)

(* short_fn_defn is a stretch goal *)
fn_defn = long_fn_defn (* | short_fn_defn *)

long_fn_defn = 'fn', blank,
            '(', [ id_lst | blank ], ')', blank,
            '->', blank, '{', blank, {  ( expr | decl), sep },
                [ return_statement, sep ], blank '}', sep
            ;

return_statement = 'return', blank, expr, sep ;

id_lst = { id, blank, ',', blank, }, id, blank ;

expr = ( '(', blank, expr, blank, ')' )
        | id
        | primitive_literal
        | array_construction
        | array_access
        | map_construction
        | map_access
        | binary_infix_expr
        | unary_prefix_expr
        | fn_defn
        | fn_call
        | if_expr
        | reduce_expr
        | map_expr
        | foreach_expr
        ;

primitive_literal = int_literal | float_literal | bool_literal | string_literal ;

int_literal = { digit } ;

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

float_literal = { digit }, '.', [ { digit } ] ;

bool_literal = 'true' | 'false' ;

(* I don't know how to encode escape sequences in EBNF but those are allowed *)
string_literal = '"', chars - '"', '"' ;

array_construction = '[', blank, [ { expr, blank, ',', blank } ], [','], blank ']' ;

(* Does this allow for chained access? a[1][2] *)
array_access = ( id | '(', blank, expr, blank, ')' ),
                '[', blank, expr, blank, ']'
               ;

map_construction = '%{', blank, [ { kv_pair, blank, ',' } ], [','], blank, '}' ;

kv_pair = id_like_string_kv_pair
          | long_kv_pair
          ;

id_like_string_kv_pair = id, ':', blank, expr ;

long_kv_pair = '[', blank, expr, blank, ']:', blank, expr ;

map_access = id_like_string_map_access
             | long_map_access
             ;

(* Does this allow for chained access? a.b.c *)
id_like_string_map_access = ( id | '(', blank, expr, blank, ')' ),
                            '.', id
                            ;

(* Does this allow for chained access? a[1][2] *)
long_map_access = ( id | '(', blank, expr, blank, ')' ),
                            '[', blank, expr, blank, ']'
                  ;

(* Do map and array access allow for chaining? foo.bar[3].beep *)

binary_infix_expr = expr, blank, binary_infix_op, blank, expr ;

binary_infix_op = '+' | '-' | '*' | '/' ;

                        (* maybe remove this blank *)
unary_prefix_expr = unary_prefix_op, blank, expr ;

unary_prefix_op = '+' | '-' ;

fn_call = ( id | '(', blank, expr, blank, ')' ),
            '(', [ { expr, blank, ',', blank } | expr | blank ], ')'
          ;

if_expr = 'if', blank, expr, ':', mustblank, expr, sep,
          [ { 'elif', blank, expr, ':', mustblank, expr, sep } ],
          [ 'else', blank, expr, ':', mustblank, expr, sep ]
          ;

reduce_expr = 'reduce', mustblank, expr, blank,
                'with', mustblank, expr,
                [ 'init:', mustblank, expr, sep ]

map_expr = 'map', mustblank, expr, blank,
             'with', mustblank, expr

foreach_expr = 'foreach', mustblank, expr, blank,
                 'with', mustblank, expr
