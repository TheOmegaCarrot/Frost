# this is a comment
# In a complete implementation, this file should run without error

# function definition
id = (x) -> { x }

# unused parameters
funky = (a, _, c) -> { a + c }

# last expression :: implicit return
plus = (x, y) -> { x + y }

# explicit return is available
also_plus = (x, y) -> { return x + y }

# future syntax sugar?
sugary1 = {
            a = 2
            b = 4
            a + b
        } # sugary1 == 6
# equivalent to:
desugary1 = () -> { a = 2 ; b = 4 ; a + b }

# if expressions
fib = (n) -> {
    if n <= 1: n
    else: fib(n-1) + fib(n-2) # recursion is available
}

more_if = (n) -> {
    if n == 1: 2
    elif n == 2: 10
    else: n - 1
}

# sane array syntax
arr = [ 1, 2, 3 ]

# name scoping
sum_arr = (arr) -> {
    # arr is local to function, and is distinct from global `arr`
    reduce arr with plus # language-level reduction (also, closure captures `plus`)
    # reduce <expr evaluating to array> with <expr evaluating to function> [init: <some value>] # optional init (reduction over empty w/o init can give null)
}

arr_sum = sum_arr(arr) # 6

double_arr = (arr) -> {
    map arr with (x) -> { 2 * x }
}

mapped_arr = double_arr(arr) # [2, 4, 6]

# types:

an_int = 42

a_float = 3.14

a_bool = true

a_string = "foo"

null_exists = null

a_function = (x) -> { x }

an_array = [1, 2.3, false] # dynamic typing, duck typing

array_access = an_array[1] # 2.3

a_map = %{ k1: 42, "k2": ["foo", "bar"], 4: 4, [a_string]: 18 } # key-value pairs (implicit string keys if not a literal of another type)

map_access = a_map["k1"]

sugared_map_access = a_map.k1 # only for string keys (equivalent to above)

# map reduction
map_reduce = (dict) -> {
    reduce dict with (acc, k, v) -> { acc + v } init: 0
}

map_reduce_res = map_reduce( %{ k1: 3, k2: 5 } ) # 8

# map mapping
map_map = (dict) -> {
    map a_map with (k, v) -> { [ k, v + 1] } # values at index >1 are ignored
}

map_map_res = map_map( %{ k1: 1, k2: 4 } ) # %{ k1: 2, k2: 5 }

# array iteration
iterate_array = (arr) -> {
    foreach arr with (item) -> { print(item) }
}

# map iteration
iterate_map = (dict) -> {
    foreach dict with (k, v) -> { print("%: %", k, v) }
}

# print("hi") # would be an error to uncomment

# top-level is *only* declarations, here's the entry point for proper execution
main = (args) -> {
    print("Hello World!")

    say_hi = () -> {
        print("Hi!")
    }
    say_hi() ; say_hi() # you can have semicolons
}

# loose ends
arr_concat = [1, 2, 3] + [4, 5, 6] # [1, 2, 3, 4, 5, 6]

# functions can only return one value (which can be an array or map)

str_concat = "foo" + " " + "bar" # "foo bar"

map_combine = %{ foo: "bar", baz: "beep" } + %{ beep: "boop", foo: "bloop" } # %{ foo: "bloop", baz: "beep", beep: "boop" }

logical_operations = ( true and true ) or not false

boolean_coersion = "everything except false or null is truthy" or false # true
