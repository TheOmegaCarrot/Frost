# this is a comment

# function definition
def identity = fn (x) -> { x }
assert(identity(10) == 10)

# All name declarations must start with `def`

# last expression :: implicit return
def also_plus = fn (x, y) -> { x + y } # `plus` is a predefined builtin
assert(also_plus(30, 12) == 42)

# if expressions
def fib = fn (n) -> {
    if n <= 1: n
    else: self(n-1) + self(n-2) # recursion is available
}
assert(fib(1) == 1) ; assert(fib(7) == 13)

def mutate = fn n -> {
    # n = 5 Nope, everything is immutable
}

def more_if = fn (n) -> {
    if n == 1: 2
    elif n == 2: 10
    else: n - 1
}

# this has the same meaning as the `more_if` function,
# but the formatting is ugly (but equivalent)
def also_allowed_for_if = fn (n) -> {
    if  n == 1 :
        2
        elif n == 2 :
    10
    else:
n - 1
}
assert(also_allowed_for_if(2) == 10)

# sane array syntax
def arr = [ 1, 2, 3 ]

# name scoping
def sum_arr = fn (arr) -> {
    # arr is local to function, and is distinct from global `arr`
    reduce arr with plus # language-level reduction (also, closure captures `plus`)
    # reduce <expr evaluating to array> with <expr evaluating to function> [init: <some value>]
    # optional init (reduction over empty without init returns null)
}

assert(sum_arr(arr) == 6)

def double_arr = fn (arr) -> {
    map arr with fn (x) -> { 2 * x }
}

assert(deep_equal( double_arr(arr), [2, 4, 6] ))

def remove_nulls = fn (arr) -> {
    filter arr with is_nonnull # positive filter
}

assert(deep_equal( remove_nulls( [ 42, null, "hello" ] ) , [ 42, "hello" ] ))

def only_string_keys = fn (dict) -> {
    filter dict with fn (k, v) -> { is_string(k) }
}

assert(deep_equal( only_string_keys( {foo: 42, [10]: 'hi'} ), {foo: 42} ))

# types:

def an_int = 42

def a_float = 3.14

def a_bool = true

def a_string = "foo"

def null_exists = null

def a_function = fn (x) -> { x }

def an_array = [1, 2.3, false] # dynamic typing

def array_access = an_array[1] # 2.3

def a_map = { k1: 42, k2: ["foo", "bar"], [4]: 4, [a_string]: 18 } # key-value pairs

def map_access = a_map["k1"]

def sugared_map_access = a_map.k1 # only for string keys (equivalent to above)

# map reduction
def map_reduce = fn (dict) -> {
    # map reduction requires an `init: <expr>` clause
    reduce dict with fn (acc, k, v) -> { acc + v } init: 0
}

assert(map_reduce( { k1: 3, k2: 5 } ) == 8)

# map mapping
def map_map = fn (dict) -> {
    # mapping a map - lambda returns a map which is merged into the under-the-hood accumulator
    #
    # map traversal order is unspecified, so key collisions result in
    # *something* getting overwritten. Which? Depends. Don't do that.
    map dict with fn (k, v) -> { { [k]: v + 1, [k + k]: v + 2 } }
}

assert(deep_equal( map_map( { k1: 1, k2: 4 } ) , { k1: 2, k2: 5, k1k1: 3, k2k2: 6 } ))

# array iteration
def iterate_array = fn (arr) -> {
    foreach arr with fn (item) -> { print(item) }
}

# map iteration
def iterate_map = fn (dict) -> {
    foreach dict with fn (k, v) -> { print($"${k}: ${v}") }
}

print("hi") # any values returned by top-level expressions are discarded (even the last one)

# array concat
assert(deep_equal( [1, 2, 3] + [4, 5, 6] , [1, 2, 3, 4, 5, 6] ))

# functions can only return one value (which can be an array or map)

# string concat
assert( 'foo' + ' ' + 'bar' == "foo bar" )

# map union
assert(deep_equal( {foo: "bar", baz: "beep" } + { beep: "boop", foo: "bloop" } , { foo: "bloop", baz: "beep", beep: "boop" } ))

def logical_operations = ( true and true ) or not false
assert(logical_operations == true)

def or_1 = "everything except false or null is truthy" or false
assert(or_1 == "everything except false or null is truthy")

def or_2 = false or 42 # 42
assert(or_2 == 42)

def map1 = { foo: "bar" }

def map2 = { foo: "bar" }

def maps_eq = map1 == map2 # maps and arrays use identity equality
assert(not maps_eq)

def plus_3 = fn (x) -> { 3 + x }

assert(plus_3 == plus_3) # (functions use identity equality)

def seven = plus_3(4)

# a @ f(b) is exactly identical to f(a, b)
# a @ f() is valid and is identical to f(a)
# a @ f() @ g() is a threaded chain, and is identical to g(f(a))
# a @ f(b) @ g(c) is identical to g(f(a, b), c)
# It's just an alternate function call syntax, but it _looks like_
# a left-associative operator
def threaded_seven = 4@plus_3()

def main = fn () -> {
    print("Hello World!")

    def say_hi = fn () -> {
        print("Hi!")
    }
    say_hi() ; say_hi() # you can have semicolons
}

main() # main isn't special, but it's probably good practice in larger scripts

def script_name = args[0] # predefined args array (basically argv)

# function literal sugar for 0 parameters
def sugary1 = fn -> {
            def a = 2
            def b = 4
            a + b
        } # sugary1() == 6
# equivalent to:
def desugary1 = fn () -> { def a = 2 ; def b = 4 ; a + b }

assert(sugary1() == desugary1())

def bind_front = fn (fun, ...args1) -> {
    fn (...args2) -> {
        pack_call(fun, args1 + args2) # pack_call "unpacks" an array into an argument list
        # first arg MUST be a function, second arg MUST be an array, normal arity rules apply
    }
}

def plus_5 = bind_front(plus, 5)

assert(plus_5(10) == 15)

def reduce_rest = fn (f, ...beeps) -> {
    reduce beeps with f
}

def reduce_rest_res = reduce_rest(fn (a, b) -> {a + b}, 1, 2, 3, 4)
assert(reduce_rest_res == 10)

# function parameter ()s can also just be omitted, as can {} for a single expression
def times_2 = fn n -> n * 2

# array destructuring!
def [a, b] = [1, 2]
assert(a == 1 and b == 2)

# also "rest" bindings
def [c, d, ...more] = [1, 2, 3, 4, 5]
assert(c == 1 and d == 2 and deep_equal(more, [3, 4, 5]))

# array destructuring bindings have to match exactly

# format strings!
def fmt_string = $'a = ${a}, b = ${b}'
assert(fmt_string == 'a = 1, b = 2')

# map destructuring! (does not need to be exhaustive)
def { foo: foo, bar: the, nope: nada } = { foo: 'something', bar: 42, wow: 'cool' }
assert(foo == 'something' and the == 42 and nada == null)
