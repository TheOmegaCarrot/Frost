# this is a comment
# In a complete implementation, this file should run without error

# function definition
def id = fn (x) -> { x }

# All name declarations must start with `def`

# unused parameters
def funky = fn (a, _, c) -> { a + c }

# last expression :: implicit return
def plus = fn (x, y) -> { x + y }

# explicit return is available
def also_plus = fn (x, y) -> { return x + y }

# if expressions
def fib = fn (n) -> {
    if n <= 1: n
    else: fib(n-1) + fib(n-2) # recursion is available
}

def make_counter = fn (init) -> {
    # fn () -> { init = init + 1 ; init } # mutation is not allowed (immutable everything)
}

def more_if = fn (n) -> {
    if n == 1: 2
    elif n == 2: 10
    else: n - 1
}

# this has the same meaning as the `more_if` function,
# but the formatting is ugly (but equivalent)
def also_allowed_for_if = fn (n) -> {
    if
        n == 1
        :
        2
        elif
    n == 2
        :
    10
    else:
n - 1
}

# sane array syntax
def arr = [ 1, 2, 3 ]

# name scoping
def sum_arr = fn (arr) -> {
    # arr is local to function, and is distinct from global `arr`
    reduce arr with plus # language-level reduction (also, closure captures `plus`)
    # reduce <expr evaluating to array> with <expr evaluating to function> [init: <some value>]
    # optional init (reduction over empty without init returns null)
}

def arr_sum = sum_arr(arr) # 6

def double_arr = fn (arr) -> {
    map arr with fn (x) -> { 2 * x }
}

def mapped_arr = double_arr(arr) # [2, 4, 6]

def reduce_rest = fn (f, ...beeps) -> {
    reduce beeps with f
}

def reduce_rest_res = reduce_rest(fn (a, b) -> {a + b}, 1, 2, 3, 4) # 10

# types:

def an_int = 42

def a_float = 3.14

def a_bool = true

def a_string = "foo"

def null_exists = null

def a_function = fn (x) -> { x }

def an_array = [1, 2.3, false] # dynamic typing, duck typing

def array_access = an_array[1] # 2.3

def a_map = %{ k1: 42, k2: ["foo", "bar"], [4]: 4, [a_string]: 18 } # key-value pairs

def map_access = a_map["k1"]

def sugared_map_access = a_map.k1 # only for string keys (equivalent to above)

# map reduction
def map_reduce = fn (dict) -> {
    # map reduction requires an `init: <expr>` clause
    reduce dict with fn (acc, k, v) -> { acc + v } init: 0
}

def map_reduce_res = map_reduce( %{ k1: 3, k2: 5 } ) # 8

# map mapping
def map_map = fn (dict) -> {
    # mapping a map - lambda returns a map which is merged into the under-the-hood accumulator
    #
    # map traversal order is unspecified, so key collisions result in
    # *something* getting overwritten. Which? Depends. Don't do that.
    map dict with fn (k, v) -> { %{ [k]: v + 1, [k + k]: v + 2 } }
}

def map_map_res = map_map( %{ k1: 1, k2: 4 } ) # %{ k1: 2, k2: 5, k1k1: 3, k2k2: 6 }

# array iteration
def iterate_array = fn (arr) -> {
    foreach arr with fn (item) -> { print(item) }
}

# map iteration
def iterate_map = fn (dict) -> {
    foreach dict with fn (k, v) -> { print("%: %", k, v) }
}

print("hi") # any values returned by top-level expressions are discarded (even the last one)

# loose ends
def arr_concat = [1, 2, 3] + [4, 5, 6] # [1, 2, 3, 4, 5, 6]

# functions can only return one value (which can be an array or map)

def str_concat = "foo" + " " + "bar" # "foo bar"

# %{ foo: "bloop", baz: "beep", beep: "boop" }
def map_combine = %{ foo: "bar", baz: "beep" } + %{ beep: "boop", foo: "bloop" }

def logical_operations = ( true and true ) or not false

def or_1 = "everything except false or null is truthy" or false # equals the string

def or_2 = false or 42 # 42

def map1 = %{ foo: "bar" }

def map2 = %{ foo: "bar" }

def maps_eq = map1 == map2 # maps and arrays use deep equality (maps_eq is true)

def bind_front = fn (fun, ...args1) -> {
    fn (...args2) -> {
        pack_call(fun, args1 + args2) # pack_call "unpacks" an array into an argument list
    }
}

def plus_3 = bind_front(plus, 3)

def seven = plus_3(4)

def main = fn (args) -> {
    print("Hello World!")

    def say_hi = fn () -> {
        print("Hi!")
    }
    say_hi() ; say_hi() # you can have semicolons
}
main(args) # main isn't special, but it's probably good practice in larger scripts

# deferred from v1

# function literal sugar (stretch)
def sugary1 = fn {
            def a = 2
            def b = 4
            a + b
        } # sugary1 == 6
# equivalent to:
def desugary1 = fn () -> { def a = 2 ; def b = 4 ; a + b }

# array -> map mapping (deferred)
def arr_to_map = fn (arr) -> {
    map arr into map with fn (x) -> { %{ [tostring(x)]: x } }
}

def map_arr_to_map_res = arr_to_map( [ 1, 2 ] ) # %{ ["1"]: 1, ["2"]: 2 }
